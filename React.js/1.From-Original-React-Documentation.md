# React — Learning Curve (based on react.dev)

Goal: Follow a progressive plan that maps to the official React docs at react.dev.


## Get Started

- **[Quick Start](https://react.dev/learn)**

  > A high-level introduction to React: components, JSX, props, state, and rendering. (just go with the flow, everything will be understood later)

- **[Tutorial: Tic-Tac-Toe](https://react.dev/learn/tutorial)**

  > Step-by-step tutorial building a small game while learning key React concepts. (fun little project, you can try it. If you losing confidence then just skip it and come back later, after Stage 1)

- **[Thinking in React](https://react.dev/learn/thinking-in-react)**
  > Learn how to break UI into components, design data flow, and structure React applications.
      - Break UI into components.
      - Determine data flow.
      - Build a small React app step by step.

## Learn React

### Stage 1 - Describing the UI

- **[Describing the UI](https://react.dev/learn/describing-the-ui)**

  > Core philosophy: components describe the UI based on data.

      - Components describe what the UI should look like.
      - React automatically updates the UI when data changes.

- **[Your First Component](https://react.dev/learn/your-first-component)**

  > How to define and render your first functional component.

      - Functional components are simple JS functions.
      - Return JSX from components.
      - Components can accept props.

- **[Importing and Exporting Components](https://react.dev/learn/importing-and-exporting-components)**

  > Organizing components across multiple files for modularity.

      - Use `export` and `import` to share components.
      - Keep each component in a separate file for clarity.

- **[Writing Markup with JSX](https://react.dev/learn/writing-markup-with-jsx)**

  > Learn JSX syntax and rules, and understand why React uses JSX.

      - JSX is syntactic sugar for `React.createElement`.
      - JSX must have a single root element.
      - Use `{}` to embed JS expressions.

- **[JavaScript in JSX with Curly Braces](https://react.dev/learn/jsx-curly-braces)**

  > How to embed dynamic values and expressions inside JSX.

      - Use `{}` to insert variables.
      - You can embed expressions, not statements.
      - JSX evaluates expressions at render.

- **[Passing Props to a Component](https://react.dev/learn/passing-props-to-a-component)**

  > How parent components pass data to child components using props.

      - Props are read-only.
      - Pass props as attributes in JSX.
      - Child receives props as function parameters.

- **[Conditional Rendering](https://react.dev/learn/conditional-rendering)**

  > Render different UI states based on logical conditions.

      - Use ternary operators or `&&`.
      - Return `null` to render nothing.
      - Conditional rendering can be inline or in helper functions.

- **[Rendering Lists](https://react.dev/learn/rendering-lists)**

  > Loop over arrays and render lists with proper `key` usage.

      - Use `map()` to render lists.
      - Each element needs a unique `key`.
      - Keys help React track list items efficiently.

- **[Keeping Components Pure](https://react.dev/learn/keeping-components-pure)**

  > Keep components pure for predictable rendering and state behavior.

      - Pure components always render the same output for the same props.
      - Avoid side effects in render.
      - Side effects belong in effects/hooks.

- **[Your UI as a Tree](https://react.dev/learn/your-ui-as-a-tree)**
  > Understand component hierarchies and React’s virtual DOM tree.
      - Break UI into nested components.
      - Tree structure mirrors the actual DOM.
      - Component hierarchy affects state/data flow.

---

### Stage 2 - Adding Interactivity

- **[Adding Interactivity](https://react.dev/learn/adding-interactivity)**

  > Overview of how state and events create interactive behavior.

      - Interactivity comes from state and events.
      - State changes trigger re-renders.
      - Event handlers define user interaction.

- **[Responding to Events](https://react.dev/learn/responding-to-events)**

  > Attach event handlers and understand React’s synthetic event system.

      - Use camelCase event names.
      - Pass functions as handlers.
      - Synthetic events are cross-browser compatible.

- **[State: A Component's Memory](https://react.dev/learn/state-a-components-memory)**

  > Learn how state drives UI updates and preserves data between renders.

      - Use `useState` for local state.
      - State persists between renders.
      - Calling setter triggers re-render.

- **[Render and Commit](https://react.dev/learn/render-and-commit)**

  > How React processes updates: render → diff → commit.

      - Render produces a virtual DOM tree.
      - Diffing finds minimal changes.
      - Commit applies changes to the real DOM.

- **[State as a Snapshot](https://react.dev/learn/state-as-a-snapshot)**

  > State updates are asynchronous; understand snapshots and timing.

      - Each render has a snapshot of state.
      - Multiple state updates may be batched.
      - Do not rely on current state immediately after setting it.

- **[Queueing a Series of State Updates](https://react.dev/learn/queueing-series-of-state-updates)**

  > Learn how React batches and queues multiple state updates efficiently.

      - Updates may be queued and merged.
      - Functional updates help when using previous state.
      - Batching improves performance.

- **[Updating Objects in State](https://react.dev/learn/updating-objects-in-state)**

  > Use immutable patterns to update object-based state.

      - Never mutate state directly.
      - Use spread `{...state, newProp}`.
      - Create new object references to trigger re-render.

- **[Updating Arrays in State](https://react.dev/learn/updating-arrays-in-state)**
  > Use immutable patterns to update array-based state.
      - Use `map`, `filter`, `concat` to produce new arrays.
      - Do not push/pop directly on state.
      - Maintain array immutability to avoid bugs.

---

### Stage 3 - Managing State

- **[Managing State](https://react.dev/learn/managing-state)**

  > High-level strategies for structuring and managing component state.

      - Keep state minimal.
      - Lift state up when needed.
      - Use context or reducers for shared state.

- **[Reacting to Input with State](https://react.dev/learn/reacting-to-input-with-state)**

  > Form inputs interacting with state to produce controlled components.

      - Controlled inputs mirror state.
      - Update state on change events.
      - Use `value` and `onChange` together.

- **[Choosing the State Structure](https://react.dev/learn/choosing-the-state-structure)**

  > How to shape state for clarity, minimalism, and scalability.

      - Organize state logically.
      - Avoid redundant state.
      - Consider scalability for larger apps.

- **[Sharing State Between Components](https://react.dev/learn/sharing-state-between-components)**

  > Lift state up to coordinate multiple components.

      - Pass state as props.
      - Lift shared state to closest common ancestor.
      - Prevent duplicated or conflicting state.

- **[Preserving and Resetting State](https://react.dev/learn/preserving-and-resetting-state)**

  > Understand when React preserves or resets component state.

      - Component re-mount resets state.
      - Keys can force remount.
      - Preserve state when necessary.

- **[Extracting State Logic into a Reducer](https://react.dev/learn/extracting-state-logic-into-a-reducer)**

  > Use reducers for complex or multi-step state logic.

      - `useReducer` is good for complex updates.
      - Reducers help separate logic from UI.
      - Return new state objects in reducer.

- **[Passing Data Deeply with Context](https://react.dev/learn/passing-data-deeply-with-context)**

  > Use React Context to avoid prop drilling and share state globally.

      - Create context with `createContext`.
      - Use `Provider` to pass data.
      - `useContext` consumes data in child components.

- **[Scaling Up with Reducer and Context](https://react.dev/learn/scaling-up-with-reducer-and-context)**
  > Combine reducers and context for global or shared state management.
      - Context provides global state.
      - Reducers handle complex updates.
      - Combine for scalable apps.

---

### Stage 4 - Escape Hatches

- **[Escape Hatches](https://react.dev/learn/escape-hatches)**

  > Techniques for handling non-declarative or advanced cases.

      - Use refs for imperative tasks.
      - Directly manipulate DOM if needed.
      - Avoid overcomplicating declarative code.

- **[Referencing Values with Refs](https://react.dev/learn/referencing-values-with-refs)**

  > Store mutable values without triggering re-renders.

      - `useRef` holds mutable value.
      - Does not trigger re-renders.
      - Useful for timers or DOM elements.

- **[Manipulating the DOM with Refs](https://react.dev/learn/manipulating-the-dom-with-refs)**

  > Access the DOM directly for imperative operations.

      - Access DOM nodes via ref.
      - Perform manual focus or measurement.
      - Avoid overusing; prefer declarative approach.

- **[Synchronizing with Effects](https://react.dev/learn/synchronizing-with-effects)**

  > Learn how effects work, their dependencies, cleanup, and synchronization.

      - `useEffect` runs after render.
      - Cleanup avoids memory leaks.
      - Dependencies control when effect runs.

- **[You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect)**

  > Guidelines to avoid unnecessary effects and improve performance.

      - If you can calculate something during render, you don’t need an Effect.
      - To cache expensive calculations, add `useMemo` instead of `useEffect`.
      - To reset the state of an entire component tree, pass a different `key` to it.
      - To reset a particular bit of state in response to a prop change, set it during rendering.
      - Code that runs because a component was displayed should be in Effects, the rest should be in events.
      - If you need to update the state of several components, it’s better to do it during a single event.
      - Whenever you try to synchronize state variables in different components, consider lifting state up.
      - You can fetch data with Effects, but you need to implement cleanup to avoid race conditions.

- **[Lifecycle of Reactive Effects](https://react.dev/learn/lifecycle-of-reactive-effects)**

  > How effects run, clean up, and re-run across renders.

      - Effects run after render.
      - Cleanup runs before next effect.
      - Effects re-run on dependency change.

- **[Separating Events from Effects](https://react.dev/learn/separating-events-from-effects)**

  > Why event-based logic should be separated from reactive effect logic.

      - Use effects only for reactive behavior.
      - Events handle user actions.
      - Keep logic separated for clarity.

- **[Removing Effect Dependencies](https://react.dev/learn/removing-effect-dependencies)**

  > Techniques for reducing dependency arrays and preventing infinite loops.

      - Only include necessary dependencies.
      - Avoid recreating functions inside effect.
      - Memoize handlers when needed.

- **[Reusing Logic with Custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)**
  > How to extract reusable logic into custom hooks.
      - Create a function starting with `use`.
      - Encapsulate logic and state.
      - Reuse across multiple components.
