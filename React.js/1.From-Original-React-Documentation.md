# React — Learning Curve (based on react.dev)

Goal: Follow a progressive plan that maps to the official React docs at react.dev.

## Get Started

- **[Quick Start](https://react.dev/learn)**

  > A high-level introduction to React: components, JSX, props, state, and rendering.

- **[Tutorial: Tic-Tac-Toe](https://react.dev/learn/tutorial)**

  > Step-by-step tutorial building a small game while learning key React concepts.

- **[Thinking in React](https://react.dev/learn/thinking-in-react)**
  > Learn how to break UI into components, design data flow, and structure React applications.
      - Break UI into components.
      - Determine data flow.
      - Build a small React app step by step.

## Learn React

### Stage 1 - Describing the UI

- **[Describing the UI](https://react.dev/learn/describing-the-ui)** (overview)

  > Core philosophy: components describe the UI based on data.

      - Components describe what the UI should look like.
      - React automatically updates the UI when data changes.

- **[Your First Component](https://react.dev/learn/your-first-component)**

  > How to define and render your first functional component.

      - Functional components are simple JS functions.
      - Return JSX from components.
      - Components can accept props.

- **[Importing and Exporting Components](https://react.dev/learn/importing-and-exporting-components)**

  > Organizing components across multiple files for modularity.

      - Use `export` and `import` to share components.
      - Keep each component in a separate file for clarity.

- **[Writing Markup with JSX](https://react.dev/learn/writing-markup-with-jsx)**

  > Learn JSX syntax and rules, and understand why React uses JSX.

      - JSX is syntactic sugar for `React.createElement`.
      - JSX must have a single root element.
      - Use `{}` to embed JS expressions.

- **[JavaScript in JSX with Curly Braces](https://react.dev/learn/jsx-curly-braces)**

  > How to embed dynamic values and expressions inside JSX.

      - Use `{}` to insert variables.
      - You can embed expressions, not statements.
      - JSX evaluates expressions at render.

- **[Passing Props to a Component](https://react.dev/learn/passing-props-to-a-component)**

  > How parent components pass data to child components using props.

      - Props are read-only.
      - Pass props as attributes in JSX.
      - Child receives props as function parameters.

- **[Conditional Rendering](https://react.dev/learn/conditional-rendering)**

  > Render different UI states based on logical conditions.

      - Use ternary operators or `&&`.
      - Return `null` to render nothing.
      - Conditional rendering can be inline or in helper functions.

- **[Rendering Lists](https://react.dev/learn/rendering-lists)**

  > Loop over arrays and render lists with proper `key` usage.

      - Use `map()` to render lists.
      - Each element needs a unique `key`.
      - Keys help React track list items efficiently.

- **[Keeping Components Pure](https://react.dev/learn/keeping-components-pure)**

  > Keep components pure for predictable rendering and state behavior.

      - Pure components always render the same output for the same props.
      - Avoid side effects in render.
      - Side effects belong in effects/hooks.

- **[Your UI as a Tree](https://react.dev/learn/your-ui-as-a-tree)**
  > Understand component hierarchies and React’s virtual DOM tree.
      - Break UI into nested components.
      - Tree structure mirrors the actual DOM.
      - Component hierarchy affects state/data flow.

---

### Stage 2 - Adding Interactivity

- **[Adding Interactivity](https://react.dev/learn/adding-interactivity)** (overview)

  > Overview of how state and events create interactive behavior.

      - Interactivity comes from state and events.
      - State changes trigger re-renders.
      - Event handlers define user interaction.

- **[Responding to Events](https://react.dev/learn/responding-to-events)**

  > Attach event handlers and understand React’s synthetic event system.

      - Use camelCase event names.
      - Pass functions as handlers.
      - Synthetic events are cross-browser compatible.

- **[State: A Component's Memory](https://react.dev/learn/state-a-components-memory)**

  > Learn how state drives UI updates and preserves data between renders.

      - Use `useState` for local state.
      - State persists between renders.
      - Calling setter triggers re-render.

- **[Render and Commit](https://react.dev/learn/render-and-commit)**

  > How React processes updates: render → diff → commit.

      - Render produces a virtual DOM tree.
      - Diffing finds minimal changes.
      - Commit applies changes to the real DOM.

- **[State as a Snapshot](https://react.dev/learn/state-as-a-snapshot)**

  > State updates are asynchronous; understand snapshots and timing.

      - Each render has a snapshot of state.
      - Multiple state updates may be batched.
      - Do not rely on current state immediately after setting it.

- **[Queueing a Series of State Updates](https://react.dev/learn/queueing-series-of-state-updates)**

  > Learn how React batches and queues multiple state updates efficiently.

      - Updates may be queued and merged.
      - Functional updates help when using previous state.
      - Batching improves performance.

- **[Updating Objects in State](https://react.dev/learn/updating-objects-in-state)**

  > Use immutable patterns to update object-based state.

      - Never mutate state directly.
      - Use spread `{...state, newProp}`.
      - Create new object references to trigger re-render.

- **[Updating Arrays in State](https://react.dev/learn/updating-arrays-in-state)**
  > Use immutable patterns to update array-based state.
      - Use `map`, `filter`, `concat` to produce new arrays.
      - Do not push/pop directly on state.
      - Maintain array immutability to avoid bugs.

---

### Stage 3 - Managing State

- **[Managing State](https://react.dev/learn/managing-state)** (overview)

  > High-level strategies for structuring and managing component state.

      - Keep state minimal.
      - Lift state up when needed.
      - Use context or reducers for shared state.

- **[Reacting to Input with State](https://react.dev/learn/reacting-to-input-with-state)**

  > Form inputs interacting with state to produce controlled components.

      - Declarative programming means describing the UI for each visual state rather than micromanaging the UI (imperative).
      - When developing a component:
          1. Identify all its visual states.
          2. Determine the human and computer triggers for state changes.
          3. Model the state with useState.
          4. Remove non-essential state to avoid bugs and paradoxes.
          5. Connect the event handlers to set state.

- **[Choosing the State Structure](https://react.dev/learn/choosing-the-state-structure)**

  > How to shape state for clarity, minimalism, and scalability.

      - If two state variables always update together, consider merging them into one.
      - Choose your state variables carefully to avoid creating “impossible” states.
      - Structure your state in a way that reduces the chances that you’ll make a mistake updating it.
      - Avoid redundant and duplicate state so that you don’t need to keep it in sync.
      - Don’t put props into state unless you specifically want to prevent updates.
      - For UI patterns like selection, keep ID or index in state instead of the object itself.
      - If updating deeply nested state is complicated, try flattening it.

- **[Sharing State Between Components](https://react.dev/learn/sharing-state-between-components)**

  > Lift state up to coordinate multiple components.

      - When you want to coordinate two components, move their state to their common parent.
      - Then pass the information down through props from their common parent.
      - Finally, pass the event handlers down so that the children can change the parent’s state.
      - It’s useful to consider components as “controlled” (driven by props) or “uncontrolled” (driven by state).

- **[Preserving and Resetting State](https://react.dev/learn/preserving-and-resetting-state)**

  > Understand when React preserves or resets component state.

      - React keeps state for as long as the same component is rendered at the same position.
      - State is not kept in JSX tags. It’s associated with the tree position in which you put that JSX.
      - You can force a subtree to reset its state by giving it a different key.
      - Don’t nest component definitions, or you’ll reset state by accident.

- **[Extracting State Logic into a Reducer](https://react.dev/learn/extracting-state-logic-into-a-reducer)**

  > Use reducers for complex or multi-step state logic.

      - To convert from useState to useReducer:
          1. Dispatch actions from event handlers.
          2. Write a reducer function that returns the next state for a given state and action.
          3. Replace useState with useReducer.
      - Reducers require you to write a bit more code, but they help with debugging and testing.
      - Reducers must be pure.
      - Each action describes a single user interaction.
      - Use Immer if you want to write reducers in a mutating style.

- **[Passing Data Deeply with Context](https://react.dev/learn/passing-data-deeply-with-context)**

  > Use React Context to avoid prop drilling and share state globally.

      - Context lets a component provide some information to the entire tree below it.
      - To pass context:
          1. Create and export it with export const MyContext = createContext(defaultValue).
          2. Pass it to the useContext(MyContext) Hook to read it in any child component, no matter how deep.
          3. Wrap children into <MyContext value={...}> to provide it from a parent.
      - Context passes through any components in the middle.
      - Context lets you write components that “adapt to their surroundings”.
      - Before you use context, try passing props or passing JSX as children.

- **[Scaling Up with Reducer and Context](https://react.dev/learn/scaling-up-with-reducer-and-context)**

  > Combine reducers and context for global or shared state management.

      - You can combine reducer with context to let any component read and update state above it.
      - To provide state and the dispatch function to components below:
          1. Create two contexts (for state and for dispatch functions).
          2. Provide both contexts from the component that uses the reducer.
          3. Use either context from components that need to read them.
      - You can further declutter the components by moving all wiring into one file.
          - You can export a component like TasksProvider that provides context.
          - You can also export custom Hooks like useTasks and useTasksDispatch to read it.
      - You can have many context-reducer pairs like this in your app.

---

### Stage 4 - Escape Hatches

- **[Escape Hatches](https://react.dev/learn/escape-hatches)** (overview)

  > Techniques for handling non-declarative or advanced cases.

      - Use refs for imperative tasks.
      - Directly manipulate DOM if needed.
      - Avoid overcomplicating declarative code.

- **[Referencing Values with Refs](https://react.dev/learn/referencing-values-with-refs)**

  > Store mutable values without triggering re-renders.

      - Refs are an escape hatch to hold onto values that aren’t used for rendering. You won’t need them often.
      - A ref is a plain JavaScript object with a single property called current, which you can read or set.
      - You can ask React to give you a ref by calling the useRef Hook.
      - Like state, refs let you retain information between re-renders of a component.
      - Unlike state, setting the ref’s current value does not trigger a re-render.
      - Don’t read or write ref.current during rendering. This makes your component hard to predict.

- **[Manipulating the DOM with Refs](https://react.dev/learn/manipulating-the-dom-with-refs)**

  > Access the DOM directly for imperative operations.

      - Refs are a generic concept, but most often you’ll use them to hold DOM elements.
      - You instruct React to put a DOM node into myRef.current by passing <div ref={myRef}>.
      - Usually, you will use refs for non-destructive actions like focusing, scrolling, or measuring DOM elements.
      - A component doesn’t expose its DOM nodes by default. You can opt into exposing a DOM node by using the ref prop.
      - Avoid changing DOM nodes managed by React.
      - If you do modify DOM nodes managed by React, modify parts that React has no reason to update.

- **[Synchronizing with Effects](https://react.dev/learn/synchronizing-with-effects)**

  > Learn how effects work, their dependencies, cleanup, and synchronization.

      - Unlike events, Effects are caused by rendering itself rather than a particular interaction.
      - Effects let you synchronize a component with some external system (third-party API, network, etc).
      - By default, Effects run after every render (including the initial one).
      - React will skip the Effect if all of its dependencies have the same values as during the last render.
      - You can’t “choose” your dependencies. They are determined by the code inside the Effect.
      - Empty dependency array ([]) corresponds to the component “mounting”, i.e. being added to the screen.
      - In Strict Mode, React mounts components twice (in development only!) to stress-test your Effects.
      - If your Effect breaks because of remounting, you need to implement a cleanup function.
      - React will call your cleanup function before the Effect runs next time, and during the unmount.

- **[You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect)**

  > Guidelines to avoid unnecessary effects and improve performance.

      - If you can calculate something during render, you don’t need an Effect.
      - To cache expensive calculations, add useMemo instead of useEffect.
      - To reset the state of an entire component tree, pass a different key to it.
      - To reset a particular bit of state in response to a prop change, set it during rendering.
      - Code that runs because a component was displayed should be in Effects, the rest should be in events.
      - If you need to update the state of several components, it’s better to do it during a single event.
      - Whenever you try to synchronize state variables in different components, consider lifting state up.
      - You can fetch data with Effects, but you need to implement cleanup to avoid race conditions.

- **[Lifecycle of Reactive Effects](https://react.dev/learn/lifecycle-of-reactive-effects)**

  > How effects run, clean up, and re-run across renders.

      - Components can mount, update, and unmount.
      - Each Effect has a separate lifecycle from the surrounding component.
      - Each Effect describes a separate synchronization process that can start and stop.
      - When you write and read Effects, think from each individual Effect’s perspective (how to start and stop synchronization) rather than from the component’s perspective (how it mounts, updates, or unmounts).
      - Values declared inside the component body are “reactive”.
      - Reactive values should re-synchronize the Effect because they can change over time.
      - The linter verifies that all reactive values used inside the Effect are specified as dependencies.
      - All errors flagged by the linter are legitimate. There’s always a way to fix the code to not break the rules.

- **[Separating Events from Effects](https://react.dev/learn/separating-events-from-effects)**

  > Why event-based logic should be separated from reactive effect logic.

      - Event handlers run in response to specific interactions.
      - Effects run whenever synchronization is needed.
      - Logic inside event handlers is not reactive.
      - Logic inside Effects is reactive.
      - You can move non-reactive logic from Effects into Effect Events.
      - Only call Effect Events from inside Effects.
      - Don’t pass Effect Events to other components or Hooks.

- **[Removing Effect Dependencies](https://react.dev/learn/removing-effect-dependencies)**

  > Techniques for reducing dependency arrays and preventing infinite loops.

      - Dependencies should always match the code.
      - When you’re not happy with your dependencies, what you need to edit is the code.
      - Suppressing the linter leads to very confusing bugs, and you should always avoid it.
      - To remove a dependency, you need to “prove” to the linter that it’s not necessary.
      - If some code should run in response to a specific interaction, move that code to an event handler.
      - If different parts of your Effect should re-run for different reasons, split it into several Effects.
      - If you want to update some state based on the previous state, pass an updater function.
      - If you want to read the latest value without “reacting” it, extract an Effect Event from your Effect.
      - In JavaScript, objects and functions are considered different if they were created at different times.
      - Try to avoid object and function dependencies. Move them outside the component or inside the Effect.

  Note: _You don’t choose what to put on that list, The list describes your code_

- **[Reusing Logic with Custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)**

  > How to extract reusable logic into custom hooks.

      - Create a function starting with `use`.
      - Encapsulate logic and state.
      - Reuse across multiple components.
